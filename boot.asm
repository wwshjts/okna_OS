[BITS 16]
;Управление передается по физическому адресу 0x007С00

;Настраиваем стек
;Распологаем вершину по адрессу 0x007C00
;Стек растет вниз
;Данные BIOS распологаются по 0x500 (таблица прерываний) 

cli
xor ax, ax				; устанавливаем регистр ax в ноль
mov	ss, ax				; выбираем сегмент с базой 0 
mov sp, 0x7C00			; устанавливаем cмещение относительно сегмента
sti

; регистр ds не определен в начале работы

mov ax, 0x7C0
mov ds, ax				; устанавливаем селектор сегмента в 0x7C0

;настраиваем прерывание для чтения данных
mov cx, 0x1				; начальный сектор 1; цилиндр 0
xor dh, dh				; головка 0
mov bx, 0x2000
mov es, bx				; селектор сегмента чтения 
xor bx, bx

read_another:
	; всегда обновляем ax т.к. после прерывания он затирается
	mov ah, 0x2				; номер функции
	mov al, 0x1				; всегда читаем по одному сектору
	int 0x13

	inc cl 					; инкрементируем сектор
	cmp cl, 0x12			; если сектор вышел из диапазона [1; 18]
	jg update_chs			; выставляем координатам верные значения 
	update_end:

							; обновляем селектор сегмента 
	mov si, es				; чтобы прочитать следующие 512 байт  
	add si, 0x20
	mov es, si 
	
	cmp si,0x800			; если селктор физический адрес на 0x80000
	jng end_read			; завершаем чтение
	jmp read_another		; иначе продолжаем

end_read:

endless_loop:
	jmp endless_loop

update_chs:
	mov cl, 1				; начальное значение сектора 1
	inc dh					; инкрементируем номер головки т.к. переполнились
	
	cmp dh, 1				; если головка переполнилась 
	jg inc_cyl				; инкрементируем значение цилиндра
	
	jmp update_end				

inc_head:
	xor dh, dh				; 
	inc ch					; инкрементируем цилиндр
	jmp update_end  		; за его переполнением не следим


times 510-($-$$) db 0	; Добиваем размер загрузочного сектора в 510байт
dw 0xAA55				; И последние два байта загрузочного сектора в little endian

